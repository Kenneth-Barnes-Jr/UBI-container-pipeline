# This is the base image that GitLab runners will use to run Docker commands
image: docker:24.0.5

# Docker-in-Docker service to allow building and pushing Docker images
services:
  - docker:dind

# Variables to avoid repeating values
variables:
  DOCKER_DRIVER: overlay2                                                       # Storage driver for Docker (good performance)
  AWS_REGION: us-east-1                                                         # AWS region
  ECR_REPO_NAME: ubi-flask                                                      # ECR repository name
  IMAGE_TAG_LATEST: latest                                                      # Always push a 'latest' tag
  IMAGE_TAG_SHA: $CI_COMMIT_SHORT_SHA                                           # Also push a tag based on commit SHA
  ECR_URI: $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO_NAME

# Define the stages of the pipeline
stages:
  - build    # => This will build the UBI-9 + Flask image & push the image to ECR
  - deploy   # => This will deploy the UBI-9 + Flask image by updating the ECS service to use the new image

# This section will run before each job
before_script:
  # Install necessary packages
  - apk add --no-cache python3 py3-pip bash curl jq
  - pip install awscli
  
  - echo "Logging into AWS ECR..."
# Authenticate Docker to AWS ECR
  - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URI

# Stage 1 | Build the UBI-9 + Flask image
build_image:
  stage: build
  script:
    - echo "Building Docker image ..."
    # Build the image with two tags (latest + commit SHA)
    - docker build -f ubi-container-pipeline/Dockerfile -t $ECR_URI:$IMAGE_TAG_LATEST -t $ECR_URI:$IMAGE_TAG_SHA ubi-container-pipeline/
    # Pushing the UBI-9 + Flask image to ECR
    - echo "Pushing Docker image to ECR..."
    - docker push $ECR_URI:$IMAGE_TAG_LATEST
    - docker push $ECR_URI:$IMAGE_TAG_SHA

# Stage 2 | Deploy the UBI-9 + Flask image to ECS
deploy_image:
  stage: deploy
  script:
    - echo "Deploying Docker image to ECS..."
    # Get current task definition
    - TASK_DEF=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME --query "services[0].taskDefinition" --output text --region $AWS_REGION)
    - echo "Current task definition - $TASK_DEF"
    # Get full task definition JSON, replace image, and strip unnecessary metadata
    - aws ecs describe-task-definition --task-definition $TASK_DEF --region $AWS_REGION | jq --arg IMAGE "$ECR_URI:$IMAGE_TAG_LATEST" \'.taskDefinition | .containerDefinitions[0].image=$IMAGE  | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' > new-task-def.json
    # Register new task definition
    - aws ecs register-task-definition --cli-input-json file://new-task-def.json --region $AWS_REGION
    # Update service to use new revision
    - aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME --force-new-deployment
    - echo "Deployment complete. New task definition registered and service updated."
